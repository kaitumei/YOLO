{% extends "common/front_base.html" %}
{% block title %}【HorizonSafe 界安】- AI实时监控平台{% endblock %}
{% block css %}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js"></script>
    <script src="https://api.map.baidu.com/api?type=webgl&v=1.0&ak=NiHKtaxt5JnN2k3bqpb3xzbO9DoiGDIq"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='check/css/monitor.css') }}">
{% endblock %}
{% block content %}
     <main class="dashboard-container">
        <h1 class="page-title">AI实时监控平台</h1>

        <!-- 监控开关按钮 -->
        <div class="monitor-switch-container" data-monitoring-active="{% if monitoring_active %}true{% else %}false{% endif %}">
            <button id="monitor-switch-btn" class="btn btn-danger monitor-switch-btn" type="button">
                <i class="fas fa-power-off"></i> 
                <span id="monitor-switch-text">启动监控</span>
            </button>
            <div id="monitor-status" class="monitor-status">
                监控当前已关闭
            </div>
            <span class="reset-settings" id="reset-settings"><i class="fas fa-undo-alt fa-sm"></i> 重置已保存的设置</span>
        </div>

        <!-- 主内容区布局 -->
        <div class="main-content-wrapper">
            <section id="video-container" aria-label="实时视频监控区域">
                <canvas id="videoFeedCanvas" role="img" aria-label="实时视频画面"></canvas>
                <div class="loading-indicator" id="loadingIndicator">
                    <div class="spinner" role="status">
                        <span class="visually-hidden">正在加载，请稍候...</span>
                    </div>
                    <p class="loading-text">正在连接</p>
                </div>
                
                <!-- 地图缩略图 -->
                <section id="map-thumbnail" aria-label="地图缩略图">
                    <div class="map-thumbnail-title"><i class="fas fa-map-marker-alt"></i> 地图视图</div>
                    <div class="map-thumbnail-close" aria-label="关闭地图"><i class="fas fa-times"></i></div>
                    <div id="map-thumbnail-container"></div>
                </section>
                <div class="map-thumbnail-overlay"></div>
            </section>

            <section id="detection-panel" aria-label="检测结果面板">
                 <h2><i class="fas fa-search"></i> 检测结果</h2>
                 
                 <!-- 添加标签页切换 -->
                 <div class="panel-tabs">
                    <button class="tab-btn active" data-target="live-detections"><i class="fas fa-camera"></i> 实时检测</button>
                    <button class="tab-btn" data-target="history-detections"><i class="fas fa-history"></i> 历史记录</button>
                    <button class="tab-btn" data-target="accident-detections"><i class="fas fa-car-crash"></i> 事故捕捉</button>
                 </div>
                 
                 <!-- 实时检测内容 -->
                 <div class="tab-content active" id="live-detections">
                    <div class="detection-list" id="detections-container"></div>
                 </div>
                 
                 <!-- 历史记录内容 -->
                 <div class="tab-content" id="history-detections">
                    <div class="history-actions">
                        <button id="refresh-history" class="btn btn-sm btn-secondary">
                            <i class="fas fa-sync-alt"></i> 刷新
                        </button>
                    </div>
                    <div class="detection-list" id="history-container">
                        <div class="loading-history">加载历史记录中...</div>
                    </div>
                 </div>
                 
                 <!-- 事故捕捉内容 -->
                 <div class="tab-content" id="accident-detections">
                    <div class="history-actions">
                        <button id="refresh-accidents" class="btn btn-sm btn-secondary">
                            <i class="fas fa-sync-alt"></i> 刷新
                        </button>
                        <button id="clear-accidents" class="btn btn-sm btn-danger ml-2">
                            <i class="fas fa-trash-alt"></i> 清空
                        </button>
                    </div>
                    <div class="detection-list" id="accidents-container">
                        <div class="no-history">等待事故检测...</div>
                    </div>
                 </div>
            </section>
        </div>

        <footer id="status-bar">
            <div class="status-item disconnected">
                <span class="status-indicator"></span>
                <span id="connection-status">断开连接</span>
            </div>
            <div class="status-item">
                <i class="fas fa-tachometer-alt"></i>
                <span id="fps-counter">0 FPS</span>
            </div>
            <div class="status-item">
                <span id="quality-indicator">视频质量: 高</span>
                <div class="quality-selector">
                    <select id="quality-selector" aria-label="选择视频质量">
                        <option value="HIGH">高清 (1280x720)</option>
                        <option value="MEDIUM">中等 (854x480)</option>
                        <option value="LOW">低清 (640x360)</option>
                    </select>
                    <span class="help-text">快捷键: Alt+1/2/3</span>
                </div>
            </div>
            <div class="status-item">
                <span id="frameskip-indicator">跳帧率: 3</span>
                <div class="quality-selector">
                    <select id="frameskip-selector" aria-label="选择跳帧率">
                        <option value="1">精细 (1)</option>
                        <option value="3" selected>平衡 (3)</option>
                        <option value="5">快速 (5)</option>
                        <option value="7">极速 (7)</option>
                    </select>
                    <span class="help-text">较高值=更高FPS</span>
                </div>
            </div>
        </footer>

        <!-- 控制按钮组 -->
        <div class="control-group" aria-label="视频控制">
            <button class="btn btn-primary" id="pause-resume-btn" aria-label="暂停/继续监控视频" type="button">
                <i class="fas fa-pause" aria-hidden="true"></i> <span class="btn-text">暂停</span>
            </button>
            <button class="btn btn-secondary" id="capture-btn" aria-label="截图" type="button">
                <i class="fas fa-camera" aria-hidden="true"></i> 截图
            </button>
            <button class="btn btn-danger" id="record-btn" aria-label="录制视频" type="button">
                <i class="fas fa-video" aria-hidden="true"></i> 录制
            </button>
            <a href="{{ url_for('stream.playback') }}" class="btn btn-info" id="playback-btn" aria-label="查看监控回放">
                <i class="fas fa-history" aria-hidden="true"></i> 回放
            </a>
        </div>
    </main>

    <script>
        // 使用配置对象，便于后续修改
        const CONFIG = {
            SERVER_URL: 'http://127.0.0.1:5000',  // 修改为本地Flask服务器地址
            FPS_UPDATE_INTERVAL: 1000,
            DETECTION_UPDATE_INTERVAL: 300,  // 增加检测更新间隔，减少DOM操作
            MAX_RECONNECTION_ATTEMPTS: Infinity,
            RECONNECTION_DELAY: 3000,
            IMAGE_QUALITY: 0.8,  // 图像质量设置
            MAX_DETECTIONS_DISPLAY: 10,  // 最大显示的检测结果数量
            MAX_ACCIDENT_CAPTURES: 20,   // 最大保存的事故捕捉数量
            ACCIDENT_CLASS_NAMES: ['accident', 'car accident', 'traffic accident', '事故车', '事故', 'accident car'], // 扩展事故类别名称
            VIDEO_QUALITY: {
                HIGH: {
                    width: 1280,
                    height: 720,
                    jpegQuality: 0.9
                },
                MEDIUM: {
                    width: 854,
                    height: 480,
                    jpegQuality: 0.8
                },
                LOW: {
                    width: 640,
                    height: 360,
                    jpegQuality: 0.7
                }
            },
            // 默认使用高质量视频
            CURRENT_QUALITY: 'HIGH'
        };
        
        const socket = io(CONFIG.SERVER_URL, {
            reconnection: true,
            reconnectionAttempts: CONFIG.MAX_RECONNECTION_ATTEMPTS,
            reconnectionDelay: CONFIG.RECONNECTION_DELAY,
            timeout: 10000, // 10秒连接超时
            transports: ['websocket'],  // 优先使用WebSocket传输
            upgrade: false  // 禁用传输升级，减少延迟
        });

        // 添加监控状态变量，默认为关闭状态
        let monitoringActive = document.querySelector('.monitor-switch-container').dataset.monitoringActive === 'true';
        
        // 尝试从localStorage读取保存的设置
        const savedMonitoringState = localStorage.getItem('monitoringActive');
        if (savedMonitoringState !== null) {
            monitoringActive = savedMonitoringState === 'true';
            console.log('从localStorage恢复监控状态:', monitoringActive);
        }
        
        // 摄像头状态与监控状态保持一致
        let isCameraOn = monitoringActive;

        const canvas = document.getElementById('videoFeedCanvas');
        // 设置更高的canvas分辨率以提高清晰度
        canvas.width = 1280;  
        canvas.height = 720;
        const ctx = canvas.getContext('2d');
        // 设置图像平滑选项为false，保持图像锐度
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        ctx.oImageSmoothingEnabled = false;
        let img = new Image();
        let pendingFrame = null;
        let frameCount = 0;
        let lastTime = performance.now();
        let lastUpdate = 0;
        const UPDATE_INTERVAL = 200;

        // 新增FPS计算相关变量
        let fpsValues = [];
        let fpsUpdateInterval = 1000; // 每秒更新一次FPS
        let lastFpsUpdate = performance.now();

        // 新增暂停状态变量和当前帧数据保存
        let isPaused = false;
        let currentFrame = null;
        
        // 添加帧处理队列
        let frameQueue = [];
        let isProcessingFrame = false;
        const MAX_QUEUE_SIZE = 3;  // 最大队列大小

        // 事故捕捉数组
        let accidentCaptures = [];

        function updateConnectionStatus(connected) {
            const statusElem = document.getElementById('connection-status');
            const indicatorParent = document.querySelector('.status-item');
            const loadingIndicator = document.getElementById('loadingIndicator');

            if (connected) {
                statusElem.textContent = "已连接";
                indicatorParent.classList.add('connected');
                indicatorParent.classList.remove('disconnected');
                loadingIndicator.classList.remove('active');
            } else {
                statusElem.textContent = "断开连接";
                indicatorParent.classList.add('disconnected');
                indicatorParent.classList.remove('connected');
                loadingIndicator.classList.add('active');
            }
        }

        socket.on('connect', () => {
            console.log('服务器连接成功');
            updateConnectionStatus(true);
            // 连接成功后显示通知
            showNotification('连接成功', '已成功连接到监控服务器');
            
            // 连接成功后更新监控状态
            updateMonitoringStatus();
        });

        socket.on('disconnect', () => {
            console.log('服务器连接断开');
            updateConnectionStatus(false);
            // 连接断开后显示通知
            showNotification('连接断开', '与监控服务器的连接已断开，正在尝试重新连接...', 'warning');
        });
        
        // 添加全局错误处理
        window.addEventListener('error', (event) => {
            console.error('全局错误:', event.error);
            showNotification('发生错误', '应用程序遇到了错误，请尝试刷新页面', 'error');
        });
        
        // 添加连接重试逻辑
        let reconnectAttempts = 0;
        const MAX_MANUAL_RECONNECT_ATTEMPTS = 3;
        
        function attemptReconnect() {
            if (reconnectAttempts < MAX_MANUAL_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                showNotification('正在重连', `尝试重新连接 (${reconnectAttempts}/${MAX_MANUAL_RECONNECT_ATTEMPTS})...`, 'info');
                
                // 尝试重新连接
                socket.connect();
                
                return true;
            }
            
            showNotification('连接失败', '多次尝试连接失败，请检查网络或服务器状态', 'error');
            return false;
        }
        
        // 添加手动重连按钮
        function addReconnectButton() {
            const statusBar = document.getElementById('status-bar');
            
            // 检查是否已经存在重连按钮
            if (document.getElementById('reconnect-btn')) {
                return;
            }
            
            const reconnectBtn = document.createElement('button');
            reconnectBtn.id = 'reconnect-btn';
            reconnectBtn.className = 'btn btn-small';
            reconnectBtn.textContent = '重新连接';
            reconnectBtn.addEventListener('click', () => {
                reconnectAttempts = 0;
                attemptReconnect();
            });
            
            const btnContainer = document.createElement('div');
            btnContainer.className = 'status-item';
            btnContainer.appendChild(reconnectBtn);
            
            statusBar.appendChild(btnContainer);
        }
        
        socket.on('connect_error', (err) => {
            console.error('连接错误:', err.message);
            updateConnectionStatus(false);
            showNotification('连接错误', `无法连接到服务器: ${err.message}`, 'error');
            
            // 添加重连按钮
            addReconnectButton();
        });
        
        socket.on('reconnect_failed', () => {
            console.error('重连失败');
            updateConnectionStatus(false);
            showNotification('重连失败', '无法重新连接到服务器', 'error');
            
            // 添加重连按钮
            addReconnectButton();
        });
        
        // 修复重连时加载指示器问题
        socket.on('reconnect', (attemptNumber) => {
            console.log(`重连成功，尝试次数: ${attemptNumber}`);
            updateConnectionStatus(true); // 这里应该会隐藏加载指示器，但可能有问题
            
            // 明确隐藏加载指示器
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.classList.remove('active');
                console.log('显式隐藏加载指示器');
            }
            
            showNotification('重连成功', '已重新连接到监控服务器', 'info');
            reconnectAttempts = 0;
            
            // 移除重连按钮
            const reconnectBtn = document.getElementById('reconnect-btn');
            if (reconnectBtn && reconnectBtn.parentNode) {
                reconnectBtn.parentNode.remove();
            }
            
            // 如果摄像头是打开状态，尝试恢复视频流
            if (isCameraOn) {
                socket.emit('client_camera_on');
            }
            
            // 延迟一秒后尝试恢复视频流，确保连接已稳定
            setTimeout(restoreVideoStream, 1000);
        });
        
        // 添加更多重连状态监听
        socket.on('reconnecting', (attemptNumber) => {
            console.log(`正在尝试重连，第${attemptNumber}次尝试`);
            updateConnectionStatus(false);
            
            // 确保加载指示器显示
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.classList.add('active');
            }
        });
        
        // 添加额外的连接状态检查函数
        function checkConnectionStatus() {
            if (socket.connected) {
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator && loadingIndicator.classList.contains('active')) {
                    console.log('连接已建立但加载指示器仍在显示，强制隐藏');
                    loadingIndicator.classList.remove('active');
                }
            }
        }
        
        // 定期检查连接状态（每3秒）
        setInterval(checkConnectionStatus, 3000);
        
        // 添加通知函数
        function showNotification(title, message, type = 'info') {
            // 如果环境支持原生通知API且用户已授权
            if ("Notification" in window && Notification.permission === "granted") {
                new Notification(title, { body: message });
            } else {
                // 创建简单的内置通知
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = `
                    <h4>${title}</h4>
                    <p>${message}</p>
                `;
                document.body.appendChild(notification);
                
                // 5秒后自动消失
                setTimeout(() => {
                    notification.classList.add('fade-out');
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 500);
                }, 5000);
            }
        }
        
        // 在页面加载时设置初始状态
        document.addEventListener('DOMContentLoaded', function() {
            // 已有代码
            if ("Notification" in window && Notification.permission !== "granted" && Notification.permission !== "denied") {
                Notification.requestPermission();
            }
            
            document.querySelector('.dashboard-container').classList.add('fade-in');
            // 初始显示加载指示器
            document.getElementById('loadingIndicator').classList.add('active');
            
            // 更新监控状态显示
            updateMonitoringStatus();
            
            // 如果监控默认关闭，隐藏加载指示器
            if (!monitoringActive) {
                document.getElementById('loadingIndicator').classList.remove('active');
            } else {
                // 如果监控是开启状态，通知服务器
                socket.emit('toggle_monitoring', { active: monitoringActive });
                // 开启摄像头
                socket.emit('client_camera_on');
                showNotification('已恢复设置', '已从上次的设置中恢复监控状态', 'info');
            }
            
            // 延迟加载事故记录，避免与其他初始化冲突
            setTimeout(fetchAccidentCaptures, 2000);
            
            // 增加Socket事件监听调试
            console.log('[初始化] 添加Socket.IO事件监听器');
            
            // 向服务器请求当前状态
            if (socket && socket.connected) {
                console.log('[初始化] Socket已连接，发送状态请求');
                socket.emit('get_status');
            } else {
                console.log('[初始化] Socket尚未连接，等待连接后发送状态请求');
            }
        });

        // 添加页面关闭前的保存功能
        window.addEventListener('beforeunload', function() {
            // 确保当前设置被保存
            localStorage.setItem('monitoringActive', monitoringActive);
        });

        // 改进的视频流恢复函数
        function restoreVideoStream() {
            if (!isCameraOn) return;
            
            console.log('尝试恢复视频流');
            showNotification('恢复视频', '正在尝试恢复视频流...', 'info');
            
            // 确保加载指示器显示，直到第一帧到达
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.classList.add('active');
            }
            
            // 告知服务器重新启动视频流
            socket.emit('client_camera_on');
            
            // 设置超时，如果5秒内没有收到帧，显示错误
            const streamTimeout = setTimeout(() => {
                if (loadingIndicator.classList.contains('active')) {
                    showNotification('视频恢复失败', '无法恢复视频流，请尝试手动关闭并重新打开摄像头', 'error');
                    loadingIndicator.classList.remove('active');
                }
            }, 5000);
            
            // 存储超时ID，以便在收到第一帧时清除
            window.currentStreamTimeout = streamTimeout;
        }

        // 检查是否有事故类别的检测结果 - 改进匹配逻辑
        function checkForAccident(detections) {
            console.log('[事故检测] 检查检测结果:', detections);
            
            // 确保detections是一个数组
            if (!Array.isArray(detections)) {
                console.log('[事故检测] 检测结果不是数组');
                return false;
            }
            
            // 遍历所有检测结果
            for (const detection of detections) {
                // 获取类别名称，可能存在于不同字段
                const className = (detection.class || detection.class_name || detection.name || detection.type || '').toLowerCase();
                console.log('[事故检测] 检查对象类别:', className, '置信度:', detection.confidence);
                
                // 检查是否匹配事故类别
                const isAccident = CONFIG.ACCIDENT_CLASS_NAMES.some(accidentClass => 
                    className.includes(accidentClass.toLowerCase())
                );
                
                if (isAccident) {
                    console.log('[事故检测] 检测到事故车:', className, '置信度:', detection.confidence);
                    return true;
                }
                
                // 有些模型可能将类别信息存储在嵌套结构中
                if (detection.detections && Array.isArray(detection.detections)) {
                    console.log('[事故检测] 检查嵌套检测结果');
                    if (checkForAccident(detection.detections)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 修改的帧处理函数，增加事故检测调试信息
        socket.on('update_frame', async (data) => {
            // 如果监控未开启，忽略所有帧数据
            if (!monitoringActive) return;
            
            try {
                // 清除可能存在的视频恢复超时
                if (window.currentStreamTimeout) {
                    clearTimeout(window.currentStreamTimeout);
                    window.currentStreamTimeout = null;
                    
                    // 确保加载指示器隐藏
                    const loadingIndicator = document.getElementById('loadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.classList.remove('active');
                    }
                }
                
                // 清除可能存在的摄像头连接超时
                if (window.cameraConnectionTimeout) {
                    clearTimeout(window.cameraConnectionTimeout);
                    window.cameraConnectionTimeout = null;
                }
                
                if (!isCameraOn) return;
                if (isPaused) {
                    currentFrame = data;
                    return;
                }

                // 处理检测结果
                if (data.detections && Array.isArray(data.detections)) {
                    console.log('[事故检测] 收到检测结果:', data.detections);
                    
                    // 将检测结果发送给服务器进行分析
                    if (monitoringActive && data.image) {
                        // 防抖发送，避免过多请求
                        clearTimeout(window.detectionTimeout);
                        window.detectionTimeout = setTimeout(() => {
                            socket.emit('update_detections', {
                                detections: data.detections,
                                image: data.image
                            });
                        }, 500);
                    }
                    
                    // 本地检查是否有事故类别的检测结果（保留本地检测功能）
                    if (data.image && checkForAccident(data.detections)) {
                        console.log('[事故检测] 本地确认检测到事故车，开始捕获');
                        captureAccident(data.image, data.detections);
                    }
                    
                    // 使用防抖函数更新检测信息，避免过于频繁的DOM更新
                    debounce(() => updateDetectionInfo(data.detections, true), 100)();
                    currentFrame = data;
                }
                
                // 检查是否有图像数据，如果有则处理图像
                if (data.image && data.image.length > 0) {
                    // 使用帧队列处理，避免处理积压
                    if (frameQueue.length >= MAX_QUEUE_SIZE) {
                        // 队列已满，丢弃最旧的帧
                        frameQueue.shift();
                    }
                    
                    frameQueue.push(data);
                    
                    // 如果当前没有处理帧，则开始处理
                    if (!isProcessingFrame) {
                        processNextFrame();
                    }
                }
            } catch (err) {
                console.error('帧处理错误:', err);
                showNotification('视频处理错误', '处理视频帧时出错', 'error');
            }
        });
        
        // 捕获事故帧并保存
        function captureAccident(imageData, detections) {
            try {
                console.log('[事故捕捉] 开始捕获事故');
                
                // 创建事故捕捉对象
                const accidentCapture = {
                    id: Date.now().toString(),  // 使用时间戳作为ID
                    timestamp: new Date(),
                    image: imageData,
                    detections: detections
                };
                
                // 添加到事故捕捉数组
                accidentCaptures.unshift(accidentCapture);
                console.log('[事故捕捉] 添加到本地数组，当前长度:', accidentCaptures.length);
                
                // 限制数组大小
                if (accidentCaptures.length > CONFIG.MAX_ACCIDENT_CAPTURES) {
                    accidentCaptures.pop();
                }
                
                // 更新事故捕捉UI
                updateAccidentCaptures();
                
                // 显示通知
                showNotification('检测到事故', '已捕获事故画面', 'warning');
                
                // 自动切换到事故捕捉标签页 - 只在首次捕获时切换
                if (document.querySelector('.tab-btn[data-target="accident-detections"]') && 
                    !document.querySelector('.tab-btn[data-target="accident-detections"]').classList.contains('active')) {
                    console.log('[事故捕捉] 切换到事故捕捉标签页');
                    document.querySelector('.tab-btn[data-target="accident-detections"]').click();
                }
                
                // 立即保存到服务器，不使用队列
                console.log('[事故捕捉] 发送数据到服务器');
                
                // 处理可能的图像数据问题
                if (!imageData || imageData.length === 0) {
                    console.error('[事故捕捉] 错误: 图像数据为空');
                    showNotification('捕获失败', '图像数据为空，无法保存到服务器', 'error');
                    return;
                }
                
                socket.emit('save_accident', { 
                    image: imageData, 
                    detections: detections,
                    id: accidentCapture.id,
                    timestamp: accidentCapture.timestamp.toISOString()
                });
                
                // 监听保存结果
                socket.once('accident_saved', function(response) {
                    console.log('[事故捕捉] 服务器保存成功:', response);
                    // 更新本地记录的ID为服务器生成的ID
                    if (response.id) {
                        const index = accidentCaptures.findIndex(c => c.id === accidentCapture.id);
                        if (index !== -1) {
                            accidentCaptures[index].id = response.id;
                            accidentCaptures[index].saved = true;
                        }
                    }
                });
                
                socket.once('accident_save_error', function(error) {
                    console.error('[事故捕捉] 服务器保存失败:', error);
                    showNotification('保存失败', `事故记录保存到服务器失败: ${error.message}`, 'error');
                });
                
                console.log('[事故捕捉] 捕获流程结束');
                
            } catch (error) {
                console.error('[事故捕捉] 捕获过程出错:', error);
                showNotification('捕获出错', '事故捕捉过程中发生错误', 'error');
            }
        }
        
        // 更新事故捕捉UI
        function updateAccidentCaptures() {
            const container = document.getElementById('accidents-container');
            
            // 如果没有事故捕捉，显示提示
            if (accidentCaptures.length === 0) {
                container.innerHTML = '<div class="no-history">等待事故检测...</div>';
                return;
            }
            
            // 清空容器
            container.innerHTML = '';
            
            // 添加事故捕捉
            accidentCaptures.forEach(capture => {
                const accidentItem = document.createElement('div');
                accidentItem.className = 'history-item accident-item';
                accidentItem.setAttribute('data-id', capture.id);
                
                // 格式化时间
                const captureTime = new Date(capture.timestamp);
                const formattedTime = captureTime.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                // 创建时间标签
                const timeElement = document.createElement('div');
                timeElement.className = 'history-time';
                timeElement.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> 事故捕捉 - ${formattedTime}`;
                accidentItem.appendChild(timeElement);
                
                // 创建检测结果列表
                const detectionsList = document.createElement('div');
                detectionsList.className = 'detection-details';
                
                let detections = capture.detections;
                if (Array.isArray(detections)) {
                    detections.slice(0, 5).forEach(detection => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'detection-item';
                        
                        // 高亮显示事故类别
                        const className = detection.class || '未知类别';
                        const isAccident = CONFIG.ACCIDENT_CLASS_NAMES.includes(className.toLowerCase());
                        
                        // 获取置信度
                        const confidence = detection.confidence || 0;
                        const confidencePercent = Math.round(confidence * 100);
                        
                        itemElement.innerHTML = `
                            <span class="detection-class ${isAccident ? 'text-danger' : ''}">${className}</span>
                            <span class="detection-confidence">${confidencePercent}%</span>
                        `;
                        
                        if (isAccident) {
                            itemElement.classList.add('accident-detection');
                        }
                        
                        detectionsList.appendChild(itemElement);
                    });
                }
                
                accidentItem.appendChild(detectionsList);
                
                // 添加图像
                if (capture.image) {
                    const imageElement = document.createElement('img');
                    imageElement.className = 'history-image';
                    imageElement.src = `data:image/jpeg;base64,${capture.image}`;
                    imageElement.alt = '事故捕捉图像';
                    imageElement.addEventListener('click', () => {
                        // 显示大图
                        showLargeImage(capture.image);
                    });
                    accidentItem.appendChild(imageElement);
                }
                
                // 添加操作按钮
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'accident-actions';
                
                // 下载按钮
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'btn btn-sm btn-secondary';
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> 下载';
                downloadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    downloadAccidentImage(capture);
                });
                
                // 删除按钮
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-danger ml-2';
                deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i> 删除';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteAccidentCapture(capture.id);
                });
                
                actionsContainer.appendChild(downloadBtn);
                actionsContainer.appendChild(deleteBtn);
                accidentItem.appendChild(actionsContainer);
                
                container.appendChild(accidentItem);
            });
        }
        
        // 下载事故图像
        function downloadAccidentImage(capture) {
            const a = document.createElement('a');
            a.href = `data:image/jpeg;base64,${capture.image}`;
            
            // 格式化时间为文件名
            const timestamp = new Date(capture.timestamp)
                .toISOString()
                .replace(/:/g, '-')
                .replace(/\..+/, '');
            
            a.download = `事故捕捉_${timestamp}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // 删除事故捕捉
        function deleteAccidentCapture(id) {
            if (confirm('确定要删除这条事故记录吗？')) {
                // 从数组中删除
                accidentCaptures = accidentCaptures.filter(capture => capture.id !== id);
                
                // 更新UI
                updateAccidentCaptures();
                
                // 显示通知
                showNotification('已删除', '事故记录已删除', 'info');
            }
        }
        
        // 添加事故捕捉相关CSS样式
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .accident-item {
                    border-left: 3px solid #e74c3c;
                    background-color: rgba(231, 76, 60, 0.05);
                }
                
                .accident-detection {
                    background-color: rgba(231, 76, 60, 0.1);
                    border-left: 3px solid #e74c3c;
                }
                
                .accident-actions {
                    display: flex;
                    justify-content: flex-end;
                    margin-top: 10px;
                }
                
                .ml-2 {
                    margin-left: 0.5rem;
                }
                
                .text-danger {
                    color: #e74c3c;
                    font-weight: bold;
                }
            </style>
        `);
        
        // 清空事故捕捉按钮事件
        document.getElementById('clear-accidents').addEventListener('click', function() {
            if (confirm('确定要清空所有事故记录吗？这将同时清空服务器和本地存储的记录。')) {
                // 先清空本地记录
                accidentCaptures = [];
                updateAccidentCaptures();
                
                // 再清空服务器记录
                fetch('/check/api/accident_captures/clear', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        showNotification('已清空', '所有事故记录已清空', 'info');
                    } else {
                        showNotification('清空部分失败', `服务器记录清空失败: ${data.message}`, 'warning');
                    }
                })
                .catch(error => {
                    console.error('清空服务器记录失败:', error);
                    showNotification('清空部分失败', '本地记录已清空，但服务器记录清空失败', 'warning');
                });
            }
        });
        
        // 刷新事故捕捉按钮事件
        document.getElementById('refresh-accidents').addEventListener('click', function() {
            fetchAccidentCaptures();
        });
        
        // 从服务器获取事故捕捉记录
        function fetchAccidentCaptures() {
            const container = document.getElementById('accidents-container');
            container.innerHTML = '<div class="loading-history">加载事故记录中...</div>';
            
            fetch('/check/api/accident_captures')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('网络请求失败');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'success') {
                        // 合并服务器的记录与本地记录
                        if (data.captures && data.captures.length > 0) {
                            // 将服务器记录转换为本地格式
                            const serverCaptures = data.captures.map(capture => {
                                return {
                                    id: capture.id,
                                    timestamp: new Date(capture.timestamp),
                                    image: capture.image || '',
                                    detections: capture.detections,
                                    file_url: capture.file_url
                                };
                            });
                            
                            // 更新本地记录（保留带有图像的本地记录）
                            const localWithImages = accidentCaptures.filter(cap => cap.image && cap.image.length > 0);
                            
                            // 合并记录，避免重复
                            const serverIds = new Set(serverCaptures.map(cap => cap.id));
                            const uniqueLocal = localWithImages.filter(cap => !serverIds.has(cap.id));
                            
                            // 按时间排序合并后的记录
                            accidentCaptures = [...serverCaptures, ...uniqueLocal].sort((a, b) => 
                                new Date(b.timestamp) - new Date(a.timestamp));
                                
                            // 限制记录数量
                            if (accidentCaptures.length > CONFIG.MAX_ACCIDENT_CAPTURES) {
                                accidentCaptures = accidentCaptures.slice(0, CONFIG.MAX_ACCIDENT_CAPTURES);
                            }
                        }
                        
                        // 更新UI
                        updateAccidentCaptures();
                    } else {
                        container.innerHTML = `<div class="no-history">加载失败: ${data.message || '未知错误'}</div>`;
                    }
                })
                .catch(error => {
                    console.error('获取事故记录失败:', error);
                    container.innerHTML = `<div class="no-history">加载失败: ${error.message}</div>`;
                    
                    // 如果服务器请求失败，但有本地记录，仍然显示本地记录
                    if (accidentCaptures.length > 0) {
                        updateAccidentCaptures();
                    }
                });
        }

        // 处理下一帧的函数
        function processNextFrame() {
            if (frameQueue.length === 0 || isPaused || !monitoringActive) {
                isProcessingFrame = false;
                return;
            }
            
            isProcessingFrame = true;
            const data = frameQueue.shift();
            
            // 使用更高效的方式转换Base64图像
            const imageUrl = `data:image/jpeg;base64,${data.image}`;
            
            if (pendingFrame) {
                URL.revokeObjectURL(pendingFrame);
            }
            
            // 使用离屏canvas进行预渲染以提高性能
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d');
            
            img.onload = () => {
                // 如果在图像加载期间监控被关闭，则放弃处理
                if (!monitoringActive) {
                    isProcessingFrame = false;
                    return;
                }
                
                offscreenCanvas.width = img.width;
                offscreenCanvas.height = img.height;
                // 设置离屏画布的平滑选项为false，保持锐度
                offscreenCtx.imageSmoothingEnabled = false;
                offscreenCtx.webkitImageSmoothingEnabled = false;
                offscreenCtx.mozImageSmoothingEnabled = false;
                offscreenCtx.msImageSmoothingEnabled = false;
                offscreenCtx.oImageSmoothingEnabled = false;
                // 绘制图像
                offscreenCtx.drawImage(img, 0, 0, img.width, img.height);
                
                requestAnimationFrame(() => {
                    // 再次检查监控状态
                    if (!monitoringActive) {
                        isProcessingFrame = false;
                        return;
                    }
                    
                    canvas.width = offscreenCanvas.width;
                    canvas.height = offscreenCanvas.height;
                    // 确保主画布上下文的平滑选项也设为false
                    ctx.imageSmoothingEnabled = false;
                    ctx.webkitImageSmoothingEnabled = false;
                    ctx.mozImageSmoothingEnabled = false;
                    ctx.msImageSmoothingEnabled = false;
                    ctx.oImageSmoothingEnabled = false;
                    // 绘制图像
                    ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
                    frameCount++;
                    updateFps();
                    
                    // 处理完成后，继续处理队列中的下一帧
                    setTimeout(() => {
                        isProcessingFrame = false;
                        processNextFrame();
                    }, 0);
                });
            };
            img.src = imageUrl;

            const now = Date.now();
            if (now - lastUpdate >= CONFIG.DETECTION_UPDATE_INTERVAL) {
                // 使用防抖函数更新检测信息，避免过于频繁的DOM更新
                debounce(() => updateDetectionInfo(data.detections, true), 100)();
                lastUpdate = now;
            }

            currentFrame = data;
        }
        
        // 添加防抖函数以提高性能
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // 优化检测信息更新函数
        function updateDetectionInfo(detections, animate = false) {
            const container = document.getElementById('detections-container');
            
            if (container.updating) return;
            container.updating = true;
            
            // 实现虚拟列表渲染 - 对大量检测结果的优化
            const MAX_VISIBLE_ITEMS = CONFIG.MAX_DETECTIONS_DISPLAY; // 最大显示项数
            const visibleDetections = detections.slice(0, MAX_VISIBLE_ITEMS);
            
            // 使用文档片段减少DOM操作
            const fragment = document.createDocumentFragment();
            
            // 使用缓存优化重复创建的元素
            const cachedElements = {};
            
            visibleDetections.forEach(det => {
                const className = det.class || '未知类别';
                const classColors = {
                    'person': '#4285f4',
                    'car': '#34a853',
                    'truck': '#fbbc05',
                    'bicycle': '#ea4335',
                    // 可根据需要添加更多类别颜色
                };
                const borderColor = classColors[className.toLowerCase()] || '#4285f4';
                
                // 创建或重用元素
                let item = cachedElements[className];
                if (!item) {
                    item = document.createElement('div');
                    item.className = 'detection-item';
                    item.setAttribute('data-class', className.toLowerCase());
                    item.style.borderLeftColor = borderColor;
                    cachedElements[className] = item;
                } else {
                    // 清空现有内容以便重用
                    while (item.firstChild) {
                        item.removeChild(item.firstChild);
                    }
                }
                
                // 使用textContent而不是innerHTML提高性能
                const classLabel = document.createElement('div');
                classLabel.className = 'class-label';
                classLabel.textContent = className;
                item.appendChild(classLabel);
                
                const confidenceContainer = document.createElement('div');
                confidenceContainer.className = 'confidence-container';
                
                const confidenceText = document.createElement('div');
                confidenceText.className = 'confidence-text';
                
                const confLabel = document.createElement('span');
                confLabel.textContent = '置信度';
                
                const confValue = document.createElement('span');
                confValue.textContent = `${(det.confidence * 100).toFixed(1)}%`;
                
                confidenceText.appendChild(confLabel);
                confidenceText.appendChild(confValue);
                
                const confBar = document.createElement('div');
                confBar.className = 'confidence-bar';
                
                const confFill = document.createElement('div');
                confFill.className = 'confidence-fill';
                confFill.style.width = `${det.confidence * 100}%`;
                
                confBar.appendChild(confFill);
                
                confidenceContainer.appendChild(confidenceText);
                confidenceContainer.appendChild(confBar);
                
                const coords = document.createElement('div');
                coords.className = 'coordinates';
                coords.textContent = `[${det.coordinates.map(x => x.toFixed(1)).join(', ')}]`;
                
                item.appendChild(classLabel);
                item.appendChild(confidenceContainer);
                item.appendChild(coords);
                
                fragment.appendChild(item);
            });
            
            // 如果项目过多，添加"更多"指示器
            if (detections.length > MAX_VISIBLE_ITEMS) {
                const moreItem = document.createElement('div');
                moreItem.className = 'detection-item more-indicator';
                moreItem.textContent = `+ 另外 ${detections.length - MAX_VISIBLE_ITEMS} 个检测结果`;
                fragment.appendChild(moreItem);
            }
            
            // 使用requestAnimationFrame优化渲染
            requestAnimationFrame(() => {
                // 清空容器并添加新内容
                container.innerHTML = '';
                container.appendChild(fragment);
                
                // 重置更新标志
                setTimeout(() => {
                    container.style.transition = '';
                    container.updating = false;
                }, 50);
            });
        }

        // 修改帧率计算函数
        function updateFps() {
            const now = performance.now();
            const elapsed = now - lastFpsUpdate;
            
            // 每秒更新一次FPS显示
            if (elapsed >= fpsUpdateInterval) {
                const fps = frameCount / (elapsed / 1000);
                
                // 保存最近10个FPS值用于平滑处理
                fpsValues.push(fps);
                if (fpsValues.length > 10) {
                    fpsValues.shift();
                }
                
                // 计算平均FPS值
                const avgFps = fpsValues.reduce((sum, val) => sum + val, 0) / fpsValues.length;
                
                // 更新显示
                document.getElementById('fps-counter').textContent = `${avgFps.toFixed(1)} FPS`;
                
                // 重置计数器
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // 简化性能监控函数
        function monitorPerformance() {
            requestAnimationFrame(monitorPerformance);
        }

        img.crossOrigin = "anonymous";
        monitorPerformance();

        // 暂停/恢复功能
        document.getElementById('pause-resume-btn').addEventListener('click', () => {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-resume-btn');
            const btnText = btn.querySelector('.btn-text');

            if (isPaused) {
                if (btnText) btnText.textContent = '恢复';
                btn.classList.add('btn-paused');
                showNotification('视频已暂停', '监控视频流已暂停', 'info');
            } else {
                if (btnText) btnText.textContent = '暂停';
                btn.classList.remove('btn-paused');
                
                // 恢复时重新处理当前帧
                if (currentFrame && currentFrame.image) {
                    const imageUrl = `data:image/jpeg;base64,${currentFrame.image}`;
                    
                    if (pendingFrame) {
                        URL.revokeObjectURL(pendingFrame);
                    }
                    
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        // 确保画布上下文的平滑选项为false
                        ctx.imageSmoothingEnabled = false;
                        ctx.webkitImageSmoothingEnabled = false;
                        ctx.mozImageSmoothingEnabled = false;
                        ctx.msImageSmoothingEnabled = false;
                        ctx.oImageSmoothingEnabled = false;
                        // 绘制图像
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        if (currentFrame.detections && Array.isArray(currentFrame.detections)) {
                            updateDetectionInfo(currentFrame.detections, true);
                        }
                    };
                    img.src = imageUrl;
                }
                
                // 如果帧队列不为空，重新开始处理
                if (frameQueue.length > 0 && !isProcessingFrame) {
                    processNextFrame();
                }
            }
        });

        // 监控开关按钮点击事件
        document.getElementById('monitor-switch-btn').addEventListener('click', function() {
            // 切换监控状态
            monitoringActive = !monitoringActive;
            
            // 同时也切换摄像头状态
            isCameraOn = monitoringActive;
            
            // 保存监控状态到localStorage
            localStorage.setItem('monitoringActive', monitoringActive);
            
            // 发送切换请求到服务器
            socket.emit('toggle_monitoring', { active: monitoringActive });
            
            // 如果开启监控，则开启摄像头
            if (monitoringActive) {
                // 显示加载指示器
                document.getElementById('loadingIndicator').classList.add('active');
                
                // 设置连接超时，避免无限等待
                const connectionTimeout = setTimeout(() => {
                    if (document.getElementById('loadingIndicator').classList.contains('active')) {
                        showNotification('连接超时', '无法连接到视频流，请重试', 'warning');
                        document.getElementById('loadingIndicator').classList.remove('active');
                        monitoringActive = false;
                        isCameraOn = false;
                        updateMonitoringStatus();
                        localStorage.setItem('monitoringActive', false);
                    }
                }, 10000); // 10秒超时
                
                // 存储超时ID，以便在成功时清除
                window.cameraConnectionTimeout = connectionTimeout;
                
                // 重新开始获取视频流
                socket.emit('client_camera_on');
            } else {
                // 清除可能存在的连接超时
                if (window.cameraConnectionTimeout) {
                    clearTimeout(window.cameraConnectionTimeout);
                    window.cameraConnectionTimeout = null;
                }
                
                // 停止获取视频流
                socket.emit('client_camera_off');
                
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 清空检测结果
                document.getElementById('detections-container').innerHTML = 
                    '<div class="detection-item">监控功能已关闭，没有检测数据</div>';
            }
            
            // 更新按钮状态（即时反馈）
            updateMonitoringStatus();
            
            // 显示通知
            showNotification(
                monitoringActive ? '监控已开启' : '监控已关闭', 
                monitoringActive ? '实时视频监控已启动' : '实时视频监控已停止',
                monitoringActive ? 'info' : 'warning'
            );
        });

        // 更新监控开关按钮和状态显示
        function updateMonitoringStatus() {
            const switchBtn = document.getElementById('monitor-switch-btn');
            const switchText = document.getElementById('monitor-switch-text');
            const statusText = document.getElementById('monitor-status');
            
            if (monitoringActive) {
                switchBtn.classList.remove('btn-danger');
                switchBtn.classList.add('btn-success');
                switchText.textContent = '关闭监控';
                statusText.textContent = '监控运行中';
                statusText.style.color = '#2ecc71';
            } else {
                switchBtn.classList.remove('btn-success');
                switchBtn.classList.add('btn-danger');
                switchText.textContent = '启动监控';
                statusText.textContent = '监控当前已关闭';
                statusText.style.color = '#e74c3c';
                
                // 清空画布和检测结果
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                document.getElementById('detections-container').innerHTML = 
                    '<div class="detection-item">监控功能已关闭，没有检测数据</div>';
                document.getElementById('fps-counter').textContent = '0 FPS';
            }
            
            // 更新摄像头按钮状态（隐藏原开启检测按钮，功能已整合）
            const cameraBtn = document.getElementById('toggle-camera-btn');
            if (cameraBtn) {
                cameraBtn.style.display = 'none';
            }
        }

        // 截图功能
        document.getElementById('capture-btn').addEventListener('click', () => {
            // 获取canvas的Base64数据（质量设为80%）
            const dataURL = canvas.toDataURL('image/jpeg', 0.8);
            const base64Data = dataURL.split(',')[1];

            // 发送截图数据到服务器
            socket.emit('capture', { image: base64Data });
        });

        // 接收截图结果通知
        socket.on('capture_success', (data) => {
            alert(`截图已保存为：${data.filename}`);
        });

        socket.on('capture_error', () => {
            alert('截图保存失败，请检查服务器状态');
        });

        // 简化的录制功能
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimer = null;

        // 录制按钮事件处理
        document.getElementById('record-btn').addEventListener('click', async function() {
            const btn = this;
            
            if (!isRecording) {
                try {
                    // 检查摄像头状态
                    if (!isCameraOn) {
                        showNotification('录制失败', '摄像头未开启，无法录制', 'error');
                        return;
                    }
                    
                    // 清空之前的数据
                    recordedChunks = [];
                    
                    // 检查浏览器兼容性
                    if (!window.MediaRecorder) {
                        showNotification('不支持录制', '您的浏览器不支持MediaRecorder API', 'error');
                        return;
                    }
                    
                    // 创建简单的录制选项，增加兼容性
                    let options = {};
                    
                    try {
                        // 尝试使用高品质选项
                        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                            options = { 
                                mimeType: 'video/webm;codecs=vp8',
                                videoBitsPerSecond: 800000 // 较低比特率，800kbps
                            };
                        } else if (MediaRecorder.isTypeSupported('video/webm')) {
                            options = { 
                                mimeType: 'video/webm',
                                videoBitsPerSecond: 800000
                            };
                        }
                        // 否则使用默认选项
                        
                        console.log('开始录制，使用选项:', options);
                    } catch (e) {
                        console.warn('无法使用首选编解码器，将使用默认设置', e);
                        options = {};
                    }
                    
                    // 尝试捕获画布流
                    let stream;
                    try {
                        // 捕获画布流，如果支持则使用较低帧率
                        stream = canvas.captureStream ? canvas.captureStream(20) : canvas.captureStream();
                    } catch (e) {
                        console.error('无法捕获画布流:', e);
                        showNotification('录制失败', '无法捕获视频流，您的浏览器可能不支持此功能', 'error');
                        return;
                    }
                    
                    // 创建MediaRecorder
                    try {
                        mediaRecorder = new MediaRecorder(stream, options);
                    } catch (e) {
                        console.error('创建MediaRecorder失败:', e);
                        showNotification('录制错误', `创建录制器失败: ${e.message}`, 'error');
                        return;
                    }
                    
                    // 添加数据处理
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data && event.data.size > 0) {
                            recordedChunks.push(event.data);
                            
                            // 显示当前大小
                            const totalSize = recordedChunks.reduce((size, chunk) => size + chunk.size, 0);
                            const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                            
                            // 更新大小显示
                            const sizeDisplay = document.getElementById('recording-size') || document.createElement('span');
                            sizeDisplay.id = 'recording-size';
                            sizeDisplay.textContent = `(${sizeMB} MB)`;
                            sizeDisplay.className = 'size-display';
                            
                            if (!document.getElementById('recording-size')) {
                                const textSpan = btn.querySelector('.text') || btn;
                                textSpan.appendChild(sizeDisplay);
                            }
                            
                            // 如果太大，自动停止
                            if (totalSize > 50 * 1024 * 1024) { // 50MB
                                showNotification('录制已自动停止', '录制大小超过50MB', 'warning');
                                stopRecording();
                            }
                        }
                    };
                    
                    // 停止录制处理
                    mediaRecorder.onstop = async () => {
                        clearInterval(recordingTimer);
                        isRecording = false;
                        
                        if (recordedChunks.length === 0) {
                            showNotification('录制失败', '未收集到视频数据', 'error');
                            resetRecordButton();
                            return;
                        }
                        
                        // 组合视频块
                        let mimeType = 'video/webm';
                        if (mediaRecorder.mimeType && mediaRecorder.mimeType !== '') {
                            mimeType = mediaRecorder.mimeType;
                        }
                        
                        const blob = new Blob(recordedChunks, { type: mimeType });
                        const size = (blob.size / (1024 * 1024)).toFixed(2);
                        console.log(`录制完成，大小: ${size} MB, 类型: ${mimeType}`);
                        
                        // 提供本地下载
                        window.lastRecordedVideo = blob;
                        const downloadBtn = document.getElementById('local-download-btn') || createDownloadButton();
                        downloadBtn.style.display = 'inline-flex';
                        
                        showNotification('录制完成', `视频大小: ${size} MB，您可以下载或上传`, 'info');
                        
                        // 恢复按钮状态
                        resetRecordButton();
                        
                        // 询问是否上传
                        if (confirm('录制完成，是否上传到服务器？\n(取消将仅保存到本地)')) {
                            try {
                                await uploadVideo(blob);
                            } catch (e) {
                                console.error('上传失败:', e);
                                // 自动触发下载作为备选方案
                                downloadBtn.click();
                            }
                        } else {
                            // 自动触发下载
                            downloadBtn.click();
                        }
                    };
                    
                    // 错误处理
                    mediaRecorder.onerror = (event) => {
                        console.error('录制过程中出错:', event.error);
                        showNotification('录制错误', `录制过程出错: ${event.error}`, 'error');
                        stopRecording();
                    };
                    
                    // 开始录制
                    try {
                        mediaRecorder.start(1000); // 每秒一个数据块
                        isRecording = true;
                        recordingStartTime = Date.now();
                        
                        // 更新按钮状态
                        const indicator = document.createElement('span');
                        indicator.className = 'recording-indicator';
                        btn.innerHTML = '';
                        btn.appendChild(indicator);
                        btn.appendChild(document.createTextNode('停止录制'));
                        btn.classList.add('btn-recording');
                        
                        // 添加时间显示
                        const timeDisplay = document.createElement('span');
                        timeDisplay.id = 'recording-time';
                        timeDisplay.className = 'recording-time';
                        timeDisplay.textContent = '00:00';
                        btn.appendChild(timeDisplay);
                        
                        // 开始时间计时
                        recordingTimer = setInterval(() => {
                            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                            const seconds = (elapsed % 60).toString().padStart(2, '0');
                            timeDisplay.textContent = ` ${minutes}:${seconds}`;
                            
                            // 5分钟自动停止
                            if (elapsed >= 300) {
                                showNotification('录制已自动停止', '已达到最大录制时间(5分钟)', 'info');
                                stopRecording();
                            }
                        }, 1000);
                        
                    } catch (error) {
                        console.error('启动录制失败:', error);
                        showNotification('启动录制失败', `无法开始录制: ${error.message}`, 'error');
                        isRecording = false;
                        resetRecordButton();
                    }
                    
                } catch (error) {
                    console.error('录制初始化失败:', error);
                    showNotification('录制失败', `无法初始化录制: ${error.message}`, 'error');
                    resetRecordButton();
                }
            } else {
                // 停止录制
                stopRecording();
            }
        });

        // 停止录制函数
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                try {
                    mediaRecorder.stop();
                    // 按钮状态会在onstop中重置
                } catch (error) {
                    console.error('停止录制错误:', error);
                    showNotification('停止错误', error.message, 'error');
                    resetRecordButton();
                }
            }
        }

        // 重置录制按钮
        function resetRecordButton() {
            const btn = document.getElementById('record-btn');
            btn.innerHTML = '<span class="icon">⏺</span><span class="text">开始录制</span>';
            btn.classList.remove('btn-recording');
        }

        // 创建下载按钮
        function createDownloadButton() {
            const container = document.querySelector('.control-group');
            
            // 检查按钮是否已存在
            if (document.getElementById('local-download-btn')) {
                return document.getElementById('local-download-btn');
            }
            
            const btn = document.createElement('button');
            btn.id = 'local-download-btn';
            btn.className = 'btn btn-secondary';
            btn.innerHTML = '<span class="icon">💾</span><span class="text">下载视频</span>';
            btn.style.display = 'none';
            
            btn.addEventListener('click', () => {
                if (!window.lastRecordedVideo) {
                    showNotification('无视频', '没有可下载的视频', 'warning');
                    return;
                }
                
                // 创建下载链接
                const a = document.createElement('a');
                a.href = URL.createObjectURL(window.lastRecordedVideo);
                a.download = `监控录像_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
                document.body.appendChild(a);
                a.click();
                
                // 清理
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                }, 100);
            });
            
            container.appendChild(btn);
            return btn;
        }

        // 简化的上传函数
        async function uploadVideo(blob) {
            try {
                showNotification('准备上传', '正在处理视频...', 'info');
                
                // 添加进度容器
                let progressContainer = document.getElementById('upload-progress-container');
                if (!progressContainer) {
                    progressContainer = document.createElement('div');
                    progressContainer.id = 'upload-progress-container';
                    progressContainer.className = 'progress-container';
                    
                    const progressBar = document.createElement('div');
                    progressBar.id = 'upload-progress-bar';
                    progressBar.className = 'progress-bar';
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                    
                    progressContainer.appendChild(progressBar);
                    document.querySelector('.control-group').appendChild(progressContainer);
                }
                
                progressContainer.style.display = 'block';
                
                // 根据文件大小决定上传方式
                const fileSizeMB = blob.size / (1024 * 1024);
                let result;
                
                if (fileSizeMB <= 10) {
                    // 小文件用Socket.IO
                    result = await uploadViaSocketIO(blob);
                } else {
                    // 大文件用HTTP表单
                    result = await uploadViaHTTP(blob);
                }
                
                showNotification('上传成功', '视频已成功上传到服务器', 'info');
                console.log('上传结果:', result);
                
                // 隐藏进度条
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
                return result;
            } catch (error) {
                console.error('上传失败:', error);
                document.getElementById('upload-progress-container').style.display = 'none';
                showNotification('上传失败', `错误: ${error.message}`, 'error');
                throw error;
            }
        }

        // Socket.IO上传方法
        async function uploadViaSocketIO(blob) {
            return new Promise((resolve, reject) => {
                // 先转换为Base64
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                
                reader.onload = function() {
                    try {
                        const base64data = reader.result.split(',')[1];
                        
                        // 更新进度为50%（表示转换完成）
                        updateProgress(50);
                        
                        // 设置超时处理
                        const timeout = setTimeout(() => {
                            socket.off('video_saved');
                            socket.off('video_save_error');
                            reject(new Error('上传超时'));
                        }, 60000); // 60秒超时
                        
                        // 监听成功事件
                        socket.once('video_saved', (data) => {
                            clearTimeout(timeout);
                            updateProgress(100);
                            resolve(data);
                        });
                        
                        // 监听错误事件
                        socket.once('video_save_error', (error) => {
                            clearTimeout(timeout);
                            reject(new Error(error.message || '服务器保存失败'));
                        });
                        
                        // 发送数据
                        const filename = `recording_${Date.now()}.webm`;
                        socket.emit('save_video', {
                            video: base64data,
                            filename: filename
                        });
                        
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = function() {
                    reject(new Error('文件读取失败'));
                };
            });
        }

        // HTTP上传方法
        async function uploadViaHTTP(blob) {
            return new Promise((resolve, reject) => {
                // 使用XHR获取进度信息
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                const filename = `recording_${Date.now()}.webm`;
                
                // 添加文件到表单
                formData.append('video', blob, filename);
                
                // 设置进度监听
                xhr.upload.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percent = Math.round((event.loaded / event.total) * 100);
                        updateProgress(percent);
                    }
                };
                
                // 处理完成
                xhr.onload = function() {
                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            updateProgress(100);
                            resolve(response);
                        } catch (error) {
                            reject(new Error('无法解析服务器响应'));
                        }
                    } else {
                        reject(new Error(`服务器错误: ${xhr.status}`));
                    }
                };
                
                // 错误处理
                xhr.onerror = function() {
                    reject(new Error('网络错误'));
                };
                
                xhr.ontimeout = function() {
                    reject(new Error('请求超时'));
                };
                
                // 发送请求
                xhr.open('POST', `${CONFIG.SERVER_URL}/api/video/upload`, true);
                xhr.timeout = 120000; // 2分钟超时
                xhr.send(formData);
            });
        }

        // 更新进度条
        function updateProgress(percent) {
            const progressBar = document.getElementById('upload-progress-bar');
            if (progressBar) {
                progressBar.style.width = `${percent}%`;
                progressBar.textContent = `${percent}%`;
            }
        }

        // 初始化地图缩略图
        var thumbnailMap = new BMapGL.Map('map-thumbnail-container');
        thumbnailMap.centerAndZoom('长沙', 12);
        thumbnailMap.disableDragging(); // 禁用拖动
        thumbnailMap.disableDoubleClickZoom(); // 禁用双击缩放
        thumbnailMap.disablePinchToZoom(); // 禁用双指缩放
        thumbnailMap.disableScrollWheelZoom(); // 禁用滚轮缩放

        // 添加地图控件
        thumbnailMap.addControl(new BMapGL.ScaleControl({
            anchor: BMAP_ANCHOR_BOTTOM_LEFT,
            offset: new BMapGL.Size(10, 10)
        }));

        // 添加交通流量图层
        var thumbnailTrafficLayer = new BMapGL.TrafficLayer();
        thumbnailMap.addTileLayer(thumbnailTrafficLayer);

        // 地图缩略图展开/收起功能
        const mapThumbnail = document.getElementById('map-thumbnail');
        const mapOverlay = document.querySelector('.map-thumbnail-overlay');
        const closeButton = document.querySelector('.map-thumbnail-close');
        const mapTitle = document.querySelector('.map-thumbnail-title');

        function expandMap() {
            mapThumbnail.classList.add('expanded');
            mapOverlay.classList.add('active');
            mapTitle.textContent = '实时位置地图';
            document.body.style.overflow = 'hidden'; // 防止背景滚动
            
            // 重新启用地图交互
            thumbnailMap.enableDragging();
            thumbnailMap.enableDoubleClickZoom();
            thumbnailMap.enablePinchToZoom();
            thumbnailMap.enableScrollWheelZoom();
            
            // 触发地图重新渲染
            thumbnailMap.checkResize();
        }

        function collapseMap() {
            mapThumbnail.classList.remove('expanded');
            mapOverlay.classList.remove('active');
            mapTitle.textContent = '点击展开地图';
            document.body.style.overflow = '';
            
            // 禁用地图交互
            thumbnailMap.disableDragging();
            thumbnailMap.disableDoubleClickZoom();
            thumbnailMap.disablePinchToZoom();
            thumbnailMap.disableScrollWheelZoom();
            
            // 触发地图重新渲染
            thumbnailMap.checkResize();
        }

        // 点击地图缩略图展开
        mapThumbnail.addEventListener('click', function(e) {
            // 如果点击的是关闭按钮，不展开
            if (e.target === closeButton) return;
            expandMap();
        });

        // 点击关闭按钮收起
        closeButton.addEventListener('click', function(e) {
            e.stopPropagation(); // 阻止事件冒泡
            collapseMap();
        });

        // 点击遮罩层收起
        mapOverlay.addEventListener('click', collapseMap);

        // ESC键收起地图
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && mapThumbnail.classList.contains('expanded')) {
                collapseMap();
            }
        });

        // 获取当前位置并在地图上显示
        function showCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        // 转换坐标系 (WGS84 到 BD09)
                        var convertor = new BMapGL.Convertor();
                        var point = new BMapGL.Point(position.coords.longitude, position.coords.latitude);
                        
                        convertor.translate([point], 1, 5, function(data) {
                            if (data.status === 0) {
                                var currentPt = data.points[0];
                                
                                // 在地图上标记当前位置
                                var marker = new BMapGL.Marker(currentPt);
                                thumbnailMap.clearOverlays();
                                thumbnailMap.addOverlay(marker);
                                thumbnailMap.setCenter(currentPt);
                                thumbnailMap.setZoom(15);

                                // 添加定位精度圈
                                var accuracy = position.coords.accuracy;
                                var accuracyCircle = new BMapGL.Circle(currentPt, accuracy, {
                                    strokeColor: "#3C90F7",
                                    strokeWeight: 1,
                                    strokeOpacity: 0.3,
                                    fillColor: "#3C90F7",
                                    fillOpacity: 0.1
                                });
                                thumbnailMap.addOverlay(accuracyCircle);
                            }
                        });
                    },
                    function(error) {
                        console.error('获取位置失败:', error);
                        showNotification('定位失败', '无法获取当前位置', 'error');
                    }
                );
            }
        }

        // 页面加载完成后获取位置
        document.addEventListener('DOMContentLoaded', function() {
            showCurrentLocation();
        });

        // 每5分钟更新一次位置
        setInterval(showCurrentLocation, 300000);
        
        // 添加视频处理完成的事件监听
        socket.on('video_process_complete', function(data) {
            console.log('视频处理完成:', data);
            showNotification('视频处理完成', '检测视频已处理完成，可以点击下载', 'info');
            
            // 添加或更新下载按钮
            let downloadBtn = document.getElementById('video-download-btn');
            if (!downloadBtn) {
                downloadBtn = document.createElement('button');
                downloadBtn.id = 'video-download-btn';
                downloadBtn.className = 'btn btn-success';
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> 下载处理视频';
                document.querySelector('.control-group').appendChild(downloadBtn);
            }
            
            downloadBtn.onclick = function() {
                window.location.href = data.download_url;
            };
            
            downloadBtn.style.display = 'inline-block';
        });

        // 监听监控状态变更事件
        socket.on('monitoring_status', (data) => {
            console.log('收到监控状态更新:', data);
            monitoringActive = data.active;
            // 同步保存到localStorage
            localStorage.setItem('monitoringActive', monitoringActive);
            updateMonitoringStatus();
        });
        
        // 监听监控未激活通知
        socket.on('monitoring_inactive', (data) => {
            console.log('监控未激活消息:', data);
            showNotification('监控未开启', '请先开启监控功能', 'warning');
        });

        // 添加重置设置的功能
        document.getElementById('reset-settings').addEventListener('click', function() {
            if (confirm('确定要重置监控设置吗？这将清除所有保存的监控首选项。')) {
                // 清除localStorage中的设置
                localStorage.removeItem('monitoringActive');
                
                // 重置为服务器默认状态
                monitoringActive = document.querySelector('.monitor-switch-container').dataset.monitoringActive === 'true';
                isCameraOn = monitoringActive;
                
                // 通知服务器
                socket.emit('toggle_monitoring', { active: monitoringActive });
                
                // 更新UI
                updateMonitoringStatus();
                
                // 如果摄像头应该开启，确保它开启
                if (monitoringActive) {
                    socket.emit('client_camera_on');
                } else {
                    socket.emit('client_camera_off');
                    // 清空画布
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                
                showNotification('设置已重置', '已恢复到系统默认设置', 'info');
            }
        });

        // 添加历史记录相关CSS样式
        document.head.insertAdjacentHTML('beforeend', `
            <style>
                .panel-tabs {
                    display: flex;
                    border-bottom: 1px solid #ddd;
                    margin-bottom: 10px;
                }
                
                .tab-btn {
                    padding: 8px 12px;
                    background: none;
                    border: none;
                    border-bottom: 2px solid transparent;
                    cursor: pointer;
                    font-weight: 500;
                    color: #666;
                    transition: all 0.3s;
                }
                
                .tab-btn.active {
                    color: #2196F3;
                    border-bottom: 2px solid #2196F3;
                }
                
                .tab-content {
                    display: none;
                }
                
                .tab-content.active {
                    display: block;
                }
                
                .history-actions {
                    display: flex;
                    justify-content: flex-end;
                    margin-bottom: 10px;
                }
                
                .history-item {
                    border-bottom: 1px solid #eee;
                    padding: 10px;
                    margin-bottom: 5px;
                }
                
                .history-time {
                    font-size: 12px;
                    color: #666;
                    margin-bottom: 5px;
                }
                
                .history-image {
                    max-width: 100%;
                    margin-top: 8px;
                    border-radius: 4px;
                    cursor: pointer;
                }
                
                .loading-history {
                    text-align: center;
                    padding: 20px;
                    color: #666;
                }
                
                .no-history {
                    text-align: center;
                    padding: 20px;
                    color: #666;
                    font-style: italic;
                }
            </style>
        `);

        // 添加标签页切换功能
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // 移除所有标签页的active类
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // 添加当前标签页的active类
                this.classList.add('active');
                document.getElementById(this.dataset.target).classList.add('active');
                
                // 如果切换到历史记录标签页，则加载历史记录
                if (this.dataset.target === 'history-detections') {
                    loadDetectionHistory();
                }
            });
        });
        
        // 加载检测历史记录
        function loadDetectionHistory() {
            const historyContainer = document.getElementById('history-container');
            historyContainer.innerHTML = '<div class="loading-history">加载历史记录中...</div>';
            
            fetch('/check/api/detection_history')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('网络请求失败');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.status === 'success' && data.history && data.history.length > 0) {
                        // 清空容器
                        historyContainer.innerHTML = '';
                        
                        // 添加历史记录
                        data.history.forEach(record => {
                            const historyItem = document.createElement('div');
                            historyItem.className = 'history-item';
                            
                            // 格式化时间
                            const recordTime = new Date(record.timestamp);
                            const formattedTime = recordTime.toLocaleString('zh-CN', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit'
                            });
                            
                            // 创建时间标签
                            const timeElement = document.createElement('div');
                            timeElement.className = 'history-time';
                            timeElement.innerHTML = `<i class="far fa-clock"></i> ${formattedTime}`;
                            historyItem.appendChild(timeElement);
                            
                            // 创建检测结果列表
                            const detectionsList = document.createElement('div');
                            detectionsList.className = 'detection-details';
                            
                            let detections = record.detections;
                            // 处理不同格式的检测数据
                            if (!Array.isArray(detections) && typeof detections === 'object') {
                                detections = [detections];
                            }
                            
                            if (Array.isArray(detections)) {
                                detections.slice(0, 5).forEach(detection => {
                                    // 检查检测结果格式
                                    let items = detection;
                                    if (detection.detections) {
                                        items = detection.detections;
                                    }
                                    
                                    if (!Array.isArray(items)) {
                                        items = [items];
                                    }
                                    
                                    items.slice(0, 3).forEach(item => {
                                        const itemElement = document.createElement('div');
                                        itemElement.className = 'detection-item';
                                        
                                        // 获取类名
                                        const className = item.class_name || item.class || item.type || '未知对象';
                                        
                                        // 获取置信度
                                        const confidence = item.confidence || item.conf || 0;
                                        const confidencePercent = Math.round(confidence * 100);
                                        
                                        itemElement.innerHTML = `
                                            <span class="detection-class">${className}</span>
                                            <span class="detection-confidence">${confidencePercent}%</span>
                                        `;
                                        detectionsList.appendChild(itemElement);
                                    });
                                });
                            }
                            
                            historyItem.appendChild(detectionsList);
                            
                            // 如果有图像，添加图像
                            if (record.image) {
                                const imageElement = document.createElement('img');
                                imageElement.className = 'history-image';
                                imageElement.src = `data:image/jpeg;base64,${record.image}`;
                                imageElement.alt = '检测结果图像';
                                imageElement.addEventListener('click', () => {
                                    // 显示大图
                                    showLargeImage(record.image);
                                });
                                historyItem.appendChild(imageElement);
                            }
                            
                            historyContainer.appendChild(historyItem);
                        });
                    } else {
                        historyContainer.innerHTML = '<div class="no-history">暂无历史记录</div>';
                    }
                })
                .catch(error => {
                    console.error('获取历史记录失败:', error);
                    historyContainer.innerHTML = `<div class="no-history">加载失败: ${error.message}</div>`;
                });
        }
        
        // 显示大图
        function showLargeImage(base64Image) {
            // 创建模态框
            const modal = document.createElement('div');
            modal.className = 'image-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close-modal">&times;</span>
                    <img src="data:image/jpeg;base64,${base64Image}" alt="检测结果大图">
                </div>
            `;
            
            // 添加模态框样式
            const modalStyle = document.createElement('style');
            modalStyle.textContent = `
                .image-modal {
                    display: flex;
                    position: fixed;
                    z-index: 1000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.9);
                    align-items: center;
                    justify-content: center;
                }
                
                .modal-content {
                    position: relative;
                    max-width: 90%;
                    max-height: 90%;
                }
                
                .modal-content img {
                    max-width: 100%;
                    max-height: 90vh;
                    display: block;
                    margin: 0 auto;
                }
                
                .close-modal {
                    position: absolute;
                    top: -30px;
                    right: 0;
                    color: white;
                    font-size: 28px;
                    font-weight: bold;
                    cursor: pointer;
                }
            `;
            document.head.appendChild(modalStyle);
            
            // 添加到DOM
            document.body.appendChild(modal);
            
            // 关闭模态框事件
            modal.querySelector('.close-modal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            // 点击空白处关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        // 添加刷新历史记录按钮事件
        document.getElementById('refresh-history').addEventListener('click', loadDetectionHistory);

        // 监听服务器事故检测通知
        socket.on('accident_detected', function(data) {
            console.log('[事故通知] 收到服务器事故检测通知:', data);
            
            // 显示通知
            showNotification('检测到事故', '系统自动检测到事故车辆', 'warning');
            
            // 刷新事故捕捉列表
            fetchAccidentCaptures();
            
            // 自动切换到事故捕捉标签页
            if (document.querySelector('.tab-btn[data-target="accident-detections"]') && 
                !document.querySelector('.tab-btn[data-target="accident-detections"]').classList.contains('active')) {
                console.log('[事故捕捉] 自动切换到事故捕捉标签页');
                document.querySelector('.tab-btn[data-target="accident-detections"]').click();
            }
        });

        // 根据当前选择的质量级别设置参数
        function setVideoQuality(quality) {
            CONFIG.CURRENT_QUALITY = quality;
            const qualitySettings = CONFIG.VIDEO_QUALITY[quality];
            
            // 设置canvas分辨率
            canvas.width = qualitySettings.width;
            canvas.height = qualitySettings.height;
            
            // 更新UI以反映当前质量设置
            document.getElementById('quality-indicator').textContent = `视频质量: ${quality}`;
            
            // 保存设置到localStorage
            localStorage.setItem('videoQuality', quality);
            
            return qualitySettings;
        }

        // 从localStorage加载质量设置，或使用默认值
        const savedQuality = localStorage.getItem('videoQuality') || 'HIGH';
        setVideoQuality(savedQuality);

        // 添加视频质量选择器事件处理
        document.getElementById('quality-selector').addEventListener('change', function(e) {
            const selectedQuality = e.target.value;
            console.log(`正在切换视频质量到: ${selectedQuality}`);
            
            // 应用新的质量设置
            const qualitySettings = setVideoQuality(selectedQuality);
            
            // 向服务器发送画质设置请求
            socket.emit('set_video_quality', {
                quality: selectedQuality,
                width: qualitySettings.width,
                height: qualitySettings.height,
                jpegQuality: qualitySettings.jpegQuality
            });
            
            // 如果当前正在查看视频流，显示质量变更提示
            if (monitoringActive) {
                showNotification('视频质量已更改', `视频质量已设置为: ${selectedQuality}`, 'info');
            }
        });

        // 在页面加载时设置选择器的初始值
        document.addEventListener('DOMContentLoaded', function() {
            const qualitySelector = document.getElementById('quality-selector');
            const savedQuality = localStorage.getItem('videoQuality') || 'HIGH';
            qualitySelector.value = savedQuality;
        });

        // 监听服务器发来的视频质量更新消息
        socket.on('video_quality_updated', function(settings) {
            console.log('收到服务器视频质量更新:', settings);
            
            // 更新本地质量设置
            if (settings.quality) {
                // 更新选择器UI
                const qualitySelector = document.getElementById('quality-selector');
                if (qualitySelector) {
                    qualitySelector.value = settings.quality;
                }
                
                // 更新质量指示器
                const qualityIndicator = document.getElementById('quality-indicator');
                if (qualityIndicator) {
                    qualityIndicator.textContent = `视频质量: ${settings.quality}`;
                }
                
                // 更新存储的质量设置
                localStorage.setItem('videoQuality', settings.quality);
                
                // 更新Canvas设置
                CONFIG.CURRENT_QUALITY = settings.quality;
                CONFIG.VIDEO_QUALITY[settings.quality] = {
                    width: settings.width || CONFIG.VIDEO_QUALITY[settings.quality].width,
                    height: settings.height || CONFIG.VIDEO_QUALITY[settings.quality].height,
                    jpegQuality: settings.jpegQuality || CONFIG.VIDEO_QUALITY[settings.quality].jpegQuality
                };
                
                // 应用新设置
                setVideoQuality(settings.quality);
            }
        });

        // 在函数头部添加质量快捷键设置
        document.addEventListener('keydown', function(e) {
            // 只有当按下Alt键时才激活快捷键
            if (e.altKey) {
                switch(e.key) {
                    case '1':
                        // 切换至低质量
                        document.getElementById('quality-selector').value = 'LOW';
                        document.getElementById('quality-selector').dispatchEvent(new Event('change'));
                        break;
                    case '2':
                        // 切换至中等质量
                        document.getElementById('quality-selector').value = 'MEDIUM';
                        document.getElementById('quality-selector').dispatchEvent(new Event('change'));
                        break;
                    case '3':
                        // 切换至高质量
                        document.getElementById('quality-selector').value = 'HIGH';
                        document.getElementById('quality-selector').dispatchEvent(new Event('change'));
                        break;
                }
            }
        });

        // 在页面加载完成后立即向服务器发送当前质量设置
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                const savedQuality = localStorage.getItem('videoQuality') || 'HIGH';
                const qualitySelector = document.getElementById('quality-selector');
                if (qualitySelector) {
                    qualitySelector.value = savedQuality;
                    
                    // 手动触发change事件，确保服务器接收到初始质量设置
                    qualitySelector.dispatchEvent(new Event('change'));
                }
            }, 1000); // 延迟1秒确保连接已建立
        });

        // 跳帧率选择器事件处理
        document.getElementById('frameskip-selector').addEventListener('change', function(e) {
            const selectedFrameSkip = parseInt(e.target.value);
            console.log(`正在切换跳帧率到: ${selectedFrameSkip}`);
            
            // 更新界面
            document.getElementById('frameskip-indicator').textContent = `跳帧率: ${selectedFrameSkip}`;
            
            // 保存到localStorage
            localStorage.setItem('frameSkip', selectedFrameSkip);
            
            // 向服务器发送更新
            const qualitySettings = CONFIG.VIDEO_QUALITY[CONFIG.CURRENT_QUALITY];
            socket.emit('set_video_quality', {
                quality: CONFIG.CURRENT_QUALITY,
                width: qualitySettings.width,
                height: qualitySettings.height,
                jpegQuality: qualitySettings.jpegQuality,
                frameSkip: selectedFrameSkip
            });
            
            // 如果当前正在查看视频流，显示设置变更提示
            if (monitoringActive) {
                showNotification('跳帧率已更改', `跳帧率已设置为: ${selectedFrameSkip}，较高值将提高FPS但可能减少检测精度`, 'info');
            }
        });

        // 添加快捷键设置跳帧率
        document.addEventListener('keydown', function(e) {
            // 使用Shift+数字1-9设置跳帧率
            if (e.shiftKey && !e.altKey && !e.ctrlKey) {
                const num = parseInt(e.key);
                if (!isNaN(num) && num >= 1 && num <= 9) {
                    const selector = document.getElementById('frameskip-selector');
                    
                    // 找到最接近的选项
                    let closestOption = null;
                    let closestDiff = Infinity;
                    
                    Array.from(selector.options).forEach(option => {
                        const optionValue = parseInt(option.value);
                        const diff = Math.abs(optionValue - num);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            closestOption = option;
                        }
                    });
                    
                    if (closestOption) {
                        selector.value = closestOption.value;
                        selector.dispatchEvent(new Event('change'));
                    } else {
                        // 如果没有合适的选项，直接设置为输入的值
                        selector.value = selector.options[0].value;  // 默认选第一个
                        document.getElementById('frameskip-indicator').textContent = `跳帧率: ${num}`;
                        
                        // 保存到localStorage
                        localStorage.setItem('frameSkip', num);
                        
                        // 向服务器发送更新
                        const qualitySettings = CONFIG.VIDEO_QUALITY[CONFIG.CURRENT_QUALITY];
                        socket.emit('set_video_quality', {
                            quality: CONFIG.CURRENT_QUALITY,
                            width: qualitySettings.width,
                            height: qualitySettings.height,
                            jpegQuality: qualitySettings.jpegQuality,
                            frameSkip: num
                        });
                    }
                }
            }
        });

        // 在初始化时从localStorage加载跳帧率设置
        document.addEventListener('DOMContentLoaded', function() {
            // 延迟1秒确保页面完全加载
            setTimeout(function() {
                // 加载跳帧率设置
                const savedFrameSkip = localStorage.getItem('frameSkip') || '3';
                const frameskipSelector = document.getElementById('frameskip-selector');
                
                // 尝试找到匹配的选项
                const options = Array.from(frameskipSelector.options);
                const matchingOption = options.find(option => option.value === savedFrameSkip);
                
                if (matchingOption) {
                    frameskipSelector.value = savedFrameSkip;
                } else {
                    // 如果没有匹配的选项，则选择最接近的
                    const savedFrameSkipNum = parseInt(savedFrameSkip);
                    let closestOption = options[0];
                    let minDiff = Math.abs(parseInt(options[0].value) - savedFrameSkipNum);
                    
                    for (let i = 1; i < options.length; i++) {
                        const diff = Math.abs(parseInt(options[i].value) - savedFrameSkipNum);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestOption = options[i];
                        }
                    }
                    
                    frameskipSelector.value = closestOption.value;
                }
                
                // 更新显示
                document.getElementById('frameskip-indicator').textContent = `跳帧率: ${frameskipSelector.value}`;
            }, 1000);
        });

        // 从接收到的视频帧中更新FPS显示
        socket.on('update_frame', function(data) {
            // 更新FPS计数器（如果数据中包含FPS信息）
            if (data.fps) {
                const fpsCounter = document.getElementById('fps-counter');
                if (fpsCounter) {
                    fpsCounter.textContent = `${data.fps} FPS`;
                    
                    // 根据FPS值设置颜色
                    if (data.fps < 5) {
                        fpsCounter.style.color = '#e74c3c'; // 红色 - 低帧率
                    } else if (data.fps < 15) {
                        fpsCounter.style.color = '#f39c12'; // 橙色 - 中等帧率
                    } else {
                        fpsCounter.style.color = '#2ecc71'; // 绿色 - 高帧率
                    }
                }
            }
            
            // 处理帧数据...（保持原有代码）
        });
    </script>
{% endblock %}